#!/usr/bin/env node

import { runCommand } from './run-command';
import { existsSync } from 'fs';
import { dirname, resolve, parse, posix } from 'path';
import { writeFile, mkdir } from 'fs/promises';
import { hideBin } from 'yargs/helpers';
import { generate, loadCodegenConfig, CodegenConfig } from '@graphql-codegen/cli';
import { getPathToTmpCoverageStash } from '../coverage-reporter/coverageStashPath';
import gqlg from 'gql-generator';
import yargs from 'yargs';
import prettier from 'prettier';

export async function configToFile(
    config: CodegenConfig,
    outputPath = './codegen.ts'
): Promise<void> {
    const configObjectString = inspectConfig(config);

    const fileContent = `/**
 * GraphQL Code Generator Configuration
 * @see https://the-guild.dev/graphql/codegen/docs/config-reference/codegen-config
 */
import type { CodegenConfig } from '@graphql-codegen/cli';

const config: CodegenConfig = ${configObjectString};

export default config;
`;

    const prettierOptions = await prettier.resolveConfig(process.cwd()) || {};
    const formattedContent = await prettier.format(fileContent, {
        ...prettierOptions,
        parser: 'typescript',
    });

    const resolvedPath = resolve(outputPath);
    await mkdir(dirname(resolvedPath), { recursive: true });
    await writeFile(resolvedPath, formattedContent, 'utf8');
}

function inspectConfig(obj: any, depth = 0): string {
    if (depth > 20) return '{/* Depth limit exceeded */}';

    if (obj === null) return 'null';
    if (obj === undefined) return 'undefined';

    // Handle functions (hooks, custom scalars, etc.)
    if (typeof obj === 'function') {

        return obj.toString();
    }

    if (typeof obj !== 'object') {

        return JSON.stringify(obj);
    }

    if (Array.isArray(obj)) {
        if (obj.length === 0) return '[]';
        const items = obj.map(item => inspectConfig(item, depth + 1));

        return `[${items.join(', ')}]`;
    }

    if (Object.keys(obj).length === 0) return '{}';

    const entries = Object.entries(obj).map(([key, value]) => {
        const formattedKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key)
            ? key
            : JSON.stringify(key);

        return `${formattedKey}: ${inspectConfig(value, depth + 1)}`;
    });

    return `{
  ${entries.join(',\n  ')}
}`;
}

function buildCodegenConfig(
    schemas: string[],
    documents: string[][],
    gqlClients: string[],
    rawRequest: boolean,
    enumsAsConst: boolean,
    silent: boolean,
): CodegenConfig {
    return {
        generates: gqlClients.reduce((acc: any, clientPath: string, currentIndex: number) => {
            acc[clientPath] = {
                schema: schemas[currentIndex],
                documents: documents[currentIndex],
                plugins: ['typescript', 'typescript-operations', 'typescript-generic-sdk'],
                config: {
                    rawRequest,
                    enumsAsConst,
                    scalars: {
                        BigInt: 'bigint|number',
                        Date: 'string',
                    },
                },
            };

            return acc;
        }, {}),
        silent
    };
}

async function ensureDirectoryExists(filePath: string): Promise<void> {
    const directory = parse(filePath).dir;
    if (directory.length && !existsSync(directory)) {
        await mkdir(directory, { recursive: true });
    }
}

async function getSchemasFromUrls(url: string[], schema: string[], header: string[] | undefined): Promise<boolean> {
    if (url.length === schema.length) {
        const apiCalls = url.map((url, index) => ({
            url,
            schema: schema[index]
        }));

        await Promise.all(apiCalls.map(async i => {

            await ensureDirectoryExists(i.schema);

            await runCommand(
                header ?
                    `get-graphql-schema ${i.url} > ${i.schema} ${header.map(h => `-h "${h}"`).join(' ')}` :
                    `get-graphql-schema ${i.url} > ${i.schema}`
            );
            log(`Schema generated from "${i.url}" to "${i.schema}".`);
        }));

        return true;
    } else {
        log('Please provide equal count of url and schema parameters.');

        return false;
    }
}

async function appendCode(gqlFiles: string[], coverage: boolean) {

    const importFragment =  coverage ? 'getSdkRequester, coverageLogger' : 'getSdkRequester';

    const getSdkCoverageFragment = (loggerStash: string) => `coverageLogger(getSdk(getSdkRequester(apiContext, options, requestHandler)), '${loggerStash}')`;
    const getSdkFragment = () => 'getSdk(getSdkRequester(apiContext, options, requestHandler))';

    const graphqlAutogeneratedFileModification = (loggerStash?: string) => `

// This additional logic appended by playwright-graphql cli to ensure seamless integration
import { ${importFragment} } from 'playwright-graphql';

export type APIRequestContext = Parameters<typeof getSdkRequester>[0];
export type RequesterOptions = Parameters<typeof getSdkRequester>[1] | string;
export type RequestHandler = Parameters<typeof getSdkRequester>[2];

export const getClient = (apiContext: APIRequestContext, options?: RequesterOptions, requestHandler?: RequestHandler) => ${loggerStash ? getSdkCoverageFragment(loggerStash) : getSdkFragment()};

export type GqlAPI = ReturnType<typeof getClient>;

`;

    await Promise.all(
        gqlFiles.map(gqlClientFilePath => writeFile(
                gqlClientFilePath,
                graphqlAutogeneratedFileModification(coverage ? getPathToTmpCoverageStash(gqlClientFilePath) : undefined),
                { flag: 'a' }
            )
        )
    );

    log('Type Script types for Playwright auto generated type safe GQL client generated.');
}

const convertToGlob = (path: string) => `${path}/**/*.{gql,graphql}`;

let isSilent: boolean = false;
const originalLog = console.log;
// mute default gqlg logs, they are not informative
console.log = () => {};
function log(...args: string[]): void {
    if (isSilent) return;
    originalLog(...args);
}

async function main() {
    const argv = await yargs(hideBin(process.argv))
        .option('url', {
            alias: 'u',
            describe: 'Full GraphQL endpoint URL',
            type: 'array'
        })
        .option('header', {
            alias: 'h',
            describe: 'Optional authentication header for the get-graphql-schema command.',
            type: 'array'
        })
        .option('schema', {
            alias: 's',
            describe: 'Path to save the generated GraphQL schema file.',
            type: 'array',
            default: ['schema.gql']
        })
        .option('gqlDir', {
            alias: 'd',
            describe: 'Path to save the auto generated GraphQL files.',
            type: 'string',
            default: 'gql'
        })
        .option('gqlFile', {
            alias: 'f',
            describe: 'Path to save the auto generated GraphQL queries and mutations and type script types.',
            type: 'array',
            default: ['graphql.ts']
        })
        .option('document', {
            alias: 'o',
            describe: 'Glob pattern that will be added to documents.',
            type: 'array'
        })
        .option('depthLimit', {
            describe: 'Defines the maximum depth of nested fields to include in the generated GraphQL queries.',
            type: 'number',
            default: 20
        })
        .option('includeCrossReferences', {
            describe: 'There might be recursive fields in the query, so gql-generator ignores the types which have been added in the parent queries already by default. This can be disabled using the --includeCrossReferences false.',
            type: 'boolean',
            default: false
        })
        .option('introspect', {
            alias: 'i',
            describe: 'Introspect autogenerate operations, set false to turn off.',
            type: 'boolean',
            default: true
        })
        .option('codegen', {
            alias: 'c',
            describe: 'Path to save the codegen config to for type script types.',
            type: 'string',
            default: 'codegen.ts',
        })
        .option('saveCodegen', {
            describe: 'Pass to save codegen file.',
            type: 'boolean',
            default: false
        })
        .option('custom', {
            describe: 'Pass to generate client from custom codegen.ts file.',
            type: 'boolean',
            default: false
        })
        .option('raw', {
            describe: 'Pass to generate client with not type safe response.',
            type: 'boolean',
            default: false
        })
        .option('enumsAsConst', {
            describe: 'Type safe client will be build with "as const" instead of enum.',
            type: 'boolean',
            default: false
        })
        .option('coverage', {
            describe: 'Will add coverage logger to auto-generated client.',
            type: 'boolean',
            default: false
        })
        .option('silent', {
            type: 'boolean',
            description: 'Suppress all logs.',
            default: false
        })
        .version()
        .help()
        .argv;

    isSilent = argv.silent;

    if (argv.custom) {
        const codegen = await loadCodegenConfig({ configFilePath: argv.codegen });

        await generate(codegen.config, true);

        const gqlFiles = Object.keys(codegen.config.generates);

        await appendCode(gqlFiles, argv.coverage);
    } else {

        const schemas = (argv.schema as string[]).map(schema => (schema.endsWith('.gql') || schema.endsWith('.graphql')) ? schema : `${schema}.gql`);

        if (argv.url) {
            const result = await getSchemasFromUrls(argv.url as string[], argv.schema as string[], argv.header as string[]);

            if (!result) return;
        }

        for (const schema of schemas) {
            if (!existsSync(schema)) {
                log(`Schema file: "${argv.schema}" was not found.`);
                log('Exit with no generated output.');

                return;
            }
        }

        if (!argv.introspect && !argv.document) {
            log('Client can not be build without any operations, in case of introspect false set path to custom operations: "-o path/to/folder-with-operations"');
            return;
        }

        const operationsPaths: string[][] = [];

        if (argv.document) {
            const documents = argv.document as string[];
            documents.forEach((doc, index) => {
                if (operationsPaths[index]) {
                    operationsPaths[index].push(convertToGlob(doc));
                } else {
                    operationsPaths.push([convertToGlob(doc)]);
                }
            });
        }

        const buildOperationsPath = (schema: string) => posix.join(argv.gqlDir, parse(schema).name, 'autogenerated-operations');

        if (argv.introspect) {
            if (isNaN(argv.depthLimit)) {
                console.error('--depthLimit NaN but should be number');
                return;
            }

            for (let i = 0; i < schemas.length; i++) {
                const operationsPath = buildOperationsPath(schemas[i]);

                gqlg({
                    schemaFilePath: schemas[i],
                    destDirPath: operationsPath,
                    depthLimit: argv.depthLimit,
                    fileExtension: 'gql',
                    includeCrossReferences: argv.includeCrossReferences,
                });

                if (operationsPaths[i]) {
                    operationsPaths[i].push(convertToGlob(operationsPath));
                } else {
                    operationsPaths.push([convertToGlob(operationsPath)]);
                }

                log(`Operations were generated and saved to "${operationsPath}".`);
            }
        }

        const gqlFiles: string[] = (schemas.length === operationsPaths.length && operationsPaths.length === (argv.gqlFile as string[]).length) ?
            (argv.gqlFile as string[]).map(file => `${argv.gqlDir}/${file.endsWith('.ts') ? file : `${file}.ts`}`) :
            schemas.map(schema => posix.join(argv.gqlDir, `${parse(schema).name}.ts`));

        await generate(buildCodegenConfig(schemas, operationsPaths, gqlFiles, argv.raw, argv.enumsAsConst, argv.silent), true);

        await appendCode(gqlFiles, argv.coverage);

        if (argv.saveCodegen) {
            await configToFile(buildCodegenConfig(schemas, operationsPaths, gqlFiles, argv.raw, argv.enumsAsConst, argv.silent), argv.codegen);
            log(`File "${argv.codegen}" generated.`);
        }
    }
}

main().catch((err) => {
    console.error(err);
    process.exit(1);
});
