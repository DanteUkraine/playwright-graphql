#!/usr/bin/env node

import { runCommand } from './run-command';
import * as fs from 'fs';
import { writeFile, readFile, mkdir, readdir } from 'fs/promises';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';

function codegenContent(schema: string, document: string, gqlFile: string, rawRequest: boolean){
    return `import type { CodegenConfig } from '@graphql-codegen/cli';

const config: CodegenConfig = {
  overwrite: true,
  schema: '${schema}',
  documents: [
    '${document}',
  ],
  generates: {
    '${gqlFile}': {
      plugins: ['typescript', 'typescript-operations', 'typescript-generic-sdk'],
      config: {
        rawRequest: ${rawRequest},
        scalars: {
          BigInt: 'bigint|number',
          Date: 'string',
        },
      },
    },
  },
};
        
export default config;
`;
};

async function main() {
    const argv = await yargs(hideBin(process.argv))
        .option('url', {
            alias: 'u',
            describe: 'Full GraphQL endpoint URL',
            type: 'string',
        })
        .option('header', {
            alias: 'h',
            describe: 'Optional authentication header for the get-graphql-schema command.',
            type: 'array',
        })
        .option('schema', {
            alias: 's',
            describe: 'Path to save the generated GraphQL schema file.',
            type: 'string',
            default: 'schema.gql',
        })
        .option('gqlDir', {
            alias: 'd',
            describe: 'Path to save the auto generated GraphQL files.',
            type: 'string',
            default: 'gql',
        })
        .option('gqlFile', {
            alias: 'f',
            describe: 'Path to save the auto generated GraphQL queries and mutations and type script types.',
            type: 'string',
            default: 'graphql.ts',
        })
        .option('codegen', {
            alias: 'c',
            describe: 'Path to save the codegen config to for type script types.',
            type: 'string',
            default: 'codegen.ts',
        })
        .option('introspect', {
            alias: 'i',
            describe: 'Turns off auto generation of queries and mutations, for custom queries only.',
            type: 'boolean',
            default: true
        })
        .option('raw', {
            describe: 'Path to save the auto generated GraphQL queries and mutations and type script types.',
            type: 'boolean',
            default: false
        })
        .option('coverage', {
            describe: 'Will add coverage logger to auto-generated client.',
            type: 'boolean',
            default: false
        })
        .version()
        .help()
        .argv;

    if (argv.url) {
        await runCommand(
            argv.header ?
                `get-graphql-schema ${argv.url} > ${argv.schema} ${argv.header.map(h => `-h "${h}"`).join(' ')}` :
                `get-graphql-schema ${argv.url} > ${argv.schema}`
        );
        console.log(`Schema generated from "${argv.url}" to "${argv.schema}".`);
    }

    if (!fs.existsSync(argv.schema)) {
        console.log(`Schema file: "${argv.schema}" was not found.`);
        console.log('Exit with no generated output.');
        return;
    }

    const operationsPath = `${argv.gqlDir}/${argv.introspect ? 'autogenerated-operations' : 'custom-operations' }`;

    if (argv.introspect) {
        await runCommand(`gqlg --schemaFilePath ${argv.schema} --destDirPath ${operationsPath} --depthLimit 8`);

        console.log(`Operations were generated and saved to "${operationsPath}".`);
    } else {
        await mkdir(operationsPath, { recursive: true });
    }

    const codegenDefaultDocument = `${operationsPath}/**/*.gql`;
    const codegenGqlFile = `${argv.gqlDir}/${argv.gqlFile}`;

    if (fs.existsSync(argv.codegen)) {
        const mismatchLogs: string[] = [];
        const existingContent = await readFile(argv.codegen, 'utf8');

        const schemaRegex = /\sschema:\s*(['"`])(.+?)\1,/;
        const schemaMatch = existingContent.match(schemaRegex);

        if (schemaMatch) {
            if (schemaMatch[2] !== argv.schema) {
                const updatedContent = existingContent.replace(
                    schemaRegex,
                    ` schema: '${argv.schema}',`
                );
                await writeFile(argv.codegen, updatedContent, 'utf8');
                console.log(`Updated schema path in "${argv.codegen}".`);
            }
        } else {
            mismatchLogs.push(`Could not locate the schema property in "${argv.codegen}".`);
        }

        if (argv.introspect && !existingContent.includes(codegenDefaultDocument)) {
            mismatchLogs.push(`Could not path "${operationsPath}" to autogenerated operations in "${argv.codegen}".`);
        }

        if (!existingContent.includes(codegenGqlFile)) {
            mismatchLogs.push(`Could not locate path to autogenerated graphql types file "${codegenGqlFile}" in "${argv.codegen}".`);
        }

        if (mismatchLogs.length) {
            for (const log of mismatchLogs) {
                console.log(log);
            }
            console.log(`Remove file "${argv.codegen}" to generate new one or fix existing file manually.`);

            return;
        }
    } else {
        await writeFile(argv.codegen, codegenContent(argv.schema, codegenDefaultDocument, codegenGqlFile, argv.raw), 'utf8');

        console.log(`File "${argv.codegen}" generated.`);
    }

    if (!argv.introspect) {
        const dir = await readdir(operationsPath, { withFileTypes: true });
        const operations = dir.map(i => i.isFile());

        if (!operations.includes(true)) {
            console.log(`No operations found, API client "${codegenGqlFile}" was not generated, add operations and generate again.`);

            return;
        }
    }

    await runCommand(`graphql-codegen --config ${argv.codegen}`);

    const [importFragment, getSdkFragment] = argv.coverage ?
        ['getSdkRequester, coverageLogger', 'coverageLogger(getSdk(getSdkRequester(apiContext, options, requestHandler)))'] :
        ['getSdkRequester', 'getSdk(getSdkRequester(apiContext, options, requestHandler))'];

    const graphqlAutogeneratedFileModification = `

// This additional logic appended by playwright-graphql cli to ensure seamless integration
import { ${importFragment} } from 'playwright-graphql';

export type APIRequestContext = Parameters<typeof getSdkRequester>[0];
export type RequesterOptions = Parameters<typeof getSdkRequester>[1] | string;
export type RequestHandler = Parameters<typeof getSdkRequester>[2];

export const getClient = (apiContext: APIRequestContext, options?: RequesterOptions, requestHandler?: RequestHandler) => ${getSdkFragment};

export type GqlAPI = ReturnType<typeof getClient>;

`;

    await writeFile(codegenGqlFile, graphqlAutogeneratedFileModification, { flag: 'a' });

    console.log('Type Script types for Playwright auto generated type safe GQL client generated.');
}

main().catch((err) => {
    console.error(err);
    process.exit(1);
});
