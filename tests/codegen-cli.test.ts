import { promisify } from 'node:util';
import { exec } from 'child_process';
import { readdir, mkdir, rm, writeFile, readFile } from 'fs/promises';
import { startFakeGraphQLServer, stopFakeGraphQLServer, lastRequestHeaders } from './resources/gql-fake-server';
import { existsSync } from 'fs';
import * as path from 'path';
import { join } from "path";

const execAsync = promisify(exec);

describe('Setup Codegen CLI', () => {
    const cliPath = path.resolve(__dirname, '../lib/codegen-cli/setup-codegen-cli.js');
    const stabServer = 'http://localhost:4000';
    const schemaFile = 'test-schema.gql';
    const gqlDirectory = 'graphql';
    const gqlFile = 'gql.ts';
    const codegenFile = 'gql-codegen.ts';
    const testDir = path.join(__dirname, 'codegen-test');

    jest.setTimeout(15_000);

    beforeAll(async () => {
        await startFakeGraphQLServer();
    });

    afterAll(async () => {
        await stopFakeGraphQLServer();
    });

    beforeEach(async () => {
        await mkdir(testDir);
    });

    afterEach(async () => {
        if (existsSync(testDir)) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    test('generates schema and operations when no existing files', async () => {
        const cliLogs = await execAsync(
            `node ${cliPath} --url ${stabServer} --schema ${schemaFile} --gqlDir ${gqlDirectory} --gqlFile ${gqlFile} --codegen ${codegenFile}`,
            { cwd: testDir }
        );

        const dir = await readdir(testDir, { withFileTypes: true });
        expect(dir.map(i => i.name ).sort()).toEqual([ schemaFile, gqlDirectory, codegenFile ].sort());

        const codegenContent = await readFile(join(testDir, codegenFile), 'utf8');
        expect(codegenContent).toMatch(new RegExp(`\\sschema:\\s'${schemaFile}',`));
        expect(codegenContent).toMatch(new RegExp(`\\s'${gqlDirectory}\/${gqlFile}':`));
        expect(codegenContent).toMatch(new RegExp(`\\srawRequest:\\sfalse,`));

        expect(lastRequestHeaders).not.toHaveProperty('authorization');

        expect(cliLogs).toEqual({
            stdout: 'Schema generated from "http://localhost:4000" to "test-schema.gql".\n' +
                    `Operations were generated and saved to "${gqlDirectory}/autogenerated-operations".\n` +
                    `File "${codegenFile}" generated.\n` +
                    'Type Script types for Playwright auto generated type safe GQL client generated.\n',
            stderr: ''
        });
    });

    test('generates schema and operations when no existing files and headers passed', async () => {
        const cliLogs =await execAsync(`node ${cliPath} -u ${stabServer} -s ${schemaFile} -h "Authorization=Bearer blablaHash256" -h "Cookies={'Authorization': 'Bearer blablaHash'}"`, {
            cwd: testDir,
        });

        const dir = await readdir(testDir, { withFileTypes: true });
        expect(dir.map(i => i.name ).sort()).toEqual([schemaFile, 'gql', 'codegen.ts' ].sort());
        expect(lastRequestHeaders).toHaveProperty('authorization', 'Bearer blablaHash256');
        expect(lastRequestHeaders).toHaveProperty('cookies', '{\'Authorization\': \'Bearer blablaHash\'}');

        expect(cliLogs).toEqual({
            stdout: 'Schema generated from "http://localhost:4000" to "test-schema.gql".\n' +
                    'Operations were generated and saved to "gql/autogenerated-operations".\n' +
                    'File "codegen.ts" generated.\n' +
                    'Type Script types for Playwright auto generated type safe GQL client generated.\n',
            stderr: ''
        });
    });

    test('generates types from existing schema and adds coverage logger to client', async () => {
        const schemaFile = 'existing-schema.gql';
        const schemaContext = `
            type Query {
              hello: String
            }
        `;
        await writeFile(path.join(testDir, schemaFile), schemaContext);

        const cliLogs = await execAsync(`node ${cliPath} -s ${schemaFile} --coverage`, {
            cwd: testDir,
        });

        const dir = await readdir(testDir, { withFileTypes: true });
        expect(dir.map(i => i.name ).sort()).toEqual([ schemaFile, 'gql', 'codegen.ts' ].sort());

        expect(cliLogs).toEqual({
            stdout: 'Operations were generated and saved to "gql/autogenerated-operations".\n' +
                    'File "codegen.ts" generated.\n' +
                    'Type Script types for Playwright auto generated type safe GQL client generated.\n',
            stderr: ''
        });
    });

    test('updates existing codegen config if new schema path provided', async () => {
        await execAsync(`node ${cliPath} --url ${stabServer} --schema ${schemaFile}`, {
            cwd: testDir,
        });

        const updatedSchemaFile = 'updated-schema.gql';

        const cliLogs =  await execAsync(`node ${cliPath} --url ${stabServer} --schema ${updatedSchemaFile}`, {
            cwd: testDir,
        });

        const dir = await readdir(testDir, { withFileTypes: true });
        expect(dir.map(i => i.name ).sort())
            .toEqual([ schemaFile, updatedSchemaFile, 'gql', 'codegen.ts' ].sort());

        const updatedConfig = await readFile(path.join(testDir, 'codegen.ts'), 'utf8');
        expect(updatedConfig).toContain(`schema: '${updatedSchemaFile}'`);

        expect(cliLogs).toEqual({
            stdout: 'Schema generated from "http://localhost:4000" to "updated-schema.gql".\n' +
                    'Operations were generated and saved to "gql/autogenerated-operations".\n' +
                    'Updated schema path in "codegen.ts".\n' +
                    'Type Script types for Playwright auto generated type safe GQL client generated.\n',
            stderr: ''
        });
    });

    test('skip updating codegen config if related input params stay the same', async () => {
        await execAsync(`node ${cliPath} --url ${stabServer} --schema ${schemaFile}`, {
            cwd: testDir,
        });

        const cliLogs =  await execAsync(`node ${cliPath} --schema ${schemaFile}`, {
            cwd: testDir,
        });

        const dir = await readdir(testDir, { withFileTypes: true });
        expect(dir.map(i => i.name ).sort())
            .toEqual([ schemaFile, 'gql', 'codegen.ts' ].sort());

        const updatedConfig = await readFile(path.join(testDir, 'codegen.ts'), 'utf8');
        expect(updatedConfig).toContain(`schema: '${schemaFile}'`);

        expect(cliLogs).toEqual({
            stdout: 'Operations were generated and saved to "gql/autogenerated-operations".\n' +
                    'Type Script types for Playwright auto generated type safe GQL client generated.\n',
            stderr: ''
        });
    });

    test('skip execution if schema property absent in codegen.ts', async () => {
        await execAsync(`node ${cliPath} --url ${stabServer} -s ${schemaFile}`, {
            cwd: testDir,
        });

        const existingContent = await readFile(join(testDir, 'codegen.ts'), 'utf8');
        const updatedContent = existingContent.replace(/\sschema:\s*(['"`])(.+?)\1,/, `not-schema: 'schema.ts',`);
        await writeFile(join(testDir, 'codegen.ts'), updatedContent, 'utf8');

        const cliLogs =  await execAsync(`node ${cliPath} -s ${schemaFile}`, {
            cwd: testDir,
        });

        const dir = await readdir(testDir, { withFileTypes: true });
        expect(dir.map(i => i.name ).sort())
            .toEqual([ schemaFile, 'gql', 'codegen.ts' ].sort());


        expect(cliLogs).toEqual({
            stdout: 'Operations were generated and saved to "gql/autogenerated-operations".\n' +
                'Could not locate the schema property in "codegen.ts".\n' +
                'Remove file "codegen.ts" to generate new one or fix existing file manually.\n',
            stderr: ''
        });
    });

    test('skip execution if gql directory or file properties absent in codegen.ts', async () => {
        const [directory, file] = ['generated', 'types'];
        await execAsync(
            `node ${cliPath} --url ${stabServer} -s ${schemaFile} -d ${directory} -f ${file}.ts `,
            { cwd: testDir }
        );

        const cliLogs =  await execAsync(
            `node ${cliPath} -s ${schemaFile}`,
            { cwd: testDir });

        const dir = await readdir(testDir, { withFileTypes: true });
        expect(dir.map(i => i.name ).sort())
            .toEqual([ schemaFile, 'gql', directory, 'codegen.ts' ].sort());


        expect(cliLogs).toEqual({
            stdout: 'Operations were generated and saved to "gql/autogenerated-operations".\n' +
                    'Could not path \"gql/autogenerated-operations\" to autogenerated operations in \"codegen.ts\".\n' +
                    'Could not locate path to autogenerated graphql types file \"gql/graphql.ts\" in \"codegen.ts\".\n' +
                    'Remove file "codegen.ts" to generate new one or fix existing file manually.\n',
            stderr: ''
        });
    });

    test('skip execution with message about absent schema', async () => {
        const cliLogs = await execAsync(`node ${cliPath} --schema ${schemaFile}`, {
            cwd: testDir,
        });

        const dir = await readdir(testDir, { withFileTypes: true });
        expect(dir.map(i => i.name )).toHaveLength(0);


        expect(cliLogs).toEqual({
            stdout: 'Schema file: "test-schema.gql" was not found.\n' +
                    'Exit with no generated output.\n',
            stderr: ''
        });
    });

    test('generated type script should contain modification', async () => {
        await execAsync(
            `node ${cliPath} --url ${stabServer} --schema ${schemaFile} --gqlDir ${gqlDirectory} --gqlFile ${gqlFile} --raw --codegen ${codegenFile}`,
            { cwd: testDir }
        );

        const dir = await readdir(testDir, { withFileTypes: true });
        expect(dir.map(i => i.name ).sort()).toEqual([ schemaFile, gqlDirectory, codegenFile ].sort());

        const codegenContent = await readFile(join(testDir, codegenFile), 'utf8');
        expect(codegenContent).toMatch(new RegExp(`\\sschema:\\s'${schemaFile}',`));
        expect(codegenContent).toMatch(new RegExp(`\\s'${gqlDirectory}\/${gqlFile}':`));
        expect(codegenContent).toMatch(new RegExp(`\\srawRequest:\\strue,`));

        const generatedFile = await readFile(join(testDir, gqlDirectory, gqlFile), 'utf8');
        expect(generatedFile).toContain(`import { getSdkRequester } from 'playwright-graphql';`);
        expect(generatedFile).toContain(`export type APIRequestContext = Parameters<typeof getSdkRequester>[0];`);
        expect(generatedFile).toContain(`export type RequesterOptions = Parameters<typeof getSdkRequester>[1] | string;`);
        expect(generatedFile).toContain(`export type RequestHandler = Parameters<typeof getSdkRequester>[2];`);
        expect(generatedFile).toContain(`export const getClient = (apiContext: APIRequestContext, options?: RequesterOptions, requestHandler?: RequestHandler) => getSdk(getSdkRequester(apiContext, options, requestHandler));`);
        expect(generatedFile).toContain(`export type GqlAPI = ReturnType<typeof getClient>;\n`);
    });

    test('generated type script should contain modification with coverage logger', async () => {
        await execAsync(
            `node ${cliPath} --url ${stabServer} --schema ${schemaFile} --gqlDir ${gqlDirectory} --gqlFile ${gqlFile} --codegen ${codegenFile} --coverage`,
            { cwd: testDir }
        );

        const dir = await readdir(testDir, { withFileTypes: true });
        expect(dir.map(i => i.name ).sort()).toEqual([ schemaFile, gqlDirectory, codegenFile ].sort());

        const generatedFile = await readFile(join(testDir, gqlDirectory, gqlFile), 'utf8');
        expect(generatedFile).toContain(`import { getSdkRequester, coverageLogger } from 'playwright-graphql';`);
        expect(generatedFile).toContain(`export type APIRequestContext = Parameters<typeof getSdkRequester>[0];`);
        expect(generatedFile).toContain(`export type RequesterOptions = Parameters<typeof getSdkRequester>[1] | string;`);
        expect(generatedFile).toContain(`export type RequestHandler = Parameters<typeof getSdkRequester>[2];`);
        expect(generatedFile).toContain(`export const getClient = (apiContext: APIRequestContext, options?: RequesterOptions, requestHandler?: RequestHandler) => coverageLogger(getSdk(getSdkRequester(apiContext, options, requestHandler)));`);
        expect(generatedFile).toContain(`export type GqlAPI = ReturnType<typeof getClient>;\n`);
    });

});
